%
% Capítulo 3
%
\chapter{Funcionalidade da Aplicação} \label{cap3}

Uma vez o modelo feito é agora possível proceder à implementação das funcionalidades desejadas do trabalho. Estas requerem primeiro acesso às funções e procedimentos
armazenados criados na primeira parte, os quais vêm em formato das alíneas do primeiro enunciado 2d até 2l.

Com o acesso a estas funcionalidades obtido, procede-se à implementação da alínea 2h como na fase 1 mas sem usar qualquer procedimento armazenado ou função pgSql,
ou seja, limitando as possibilidades para usar apenas interações entre \texttt{JPA} e PostgreSQL. Após esta implementação é realizada outra vez mas sem a limitação,
o qual permite facilmente comparar as duas implementações e concluir qual será melhor.

Esta aplicação também permite aumentar em 20\% o número de pontos associados a um crachá, o qual foi implementado com \textit{optimistic locking} e \textit{pessimistic
locking}. A versão que utiliza \textit{optimistic locking} vem acompanhada de testes que verificam que uma mensagem de erro é levantada quando existe uma alteração
concorrente que inviabilize a operação.

%
% Secção 3.1
%
\section{Acesso às Funcionalidades da Base de Dados} \label{sec31}

O primeiro requisito é disponibilizar as funcionalidades presentes na base de dados, començando com o exercício \texttt{2d} da primeira fase até ao exercício \texttt{2l}.
Estas são apresentadas na forma de funções da aplicação.

\paragraph{Exercício 2d} Este exercício consiste em duas funções distintas, tal como na base de dados, pois estas eftuam operações diferentes. As duas funções são
\texttt{createPlayer} e \texttt{setPlayerState}. Nas listagens~\ref{lst:createPlayer} e \ref{lst:setPlayerState} encontram-se as funções \texttt{createPlayer} e
\texttt{setPlayerState}, respetivamente. Realça-se nestas implementações que a forma de chamar um função em PostgreSQL é como realizar uma \textit{query} para a 
função, tal como a \textit{string} criada na primeira linha de cada função.
\begin{minted}
[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\footnotesize,
    linenos
]
{Java}
public String createPlayer(String username, String email, String regiao) {
    String query = "SELECT createPlayer(?1, ?2, ?3)";
    Query functionQuery = em.createNativeQuery(query)
            .setParameter(1, username)
            .setParameter(2, email)
            .setParameter(3, regiao);
    return (String) functionQuery.getSingleResult();
}
\end{minted}
\captionof{listing}{Código da função createPlayer\label{lst:createPlayer}}

\begin{minted}
[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\footnotesize,
    linenos
]
{Java}
public String setPlayerState(int idJogador, String newState) {
    String query = "SELECT setPlayerState(?1, ?2)";
    Query functionQuery = em.createNativeQuery(query)
            .setParameter(1, idJogador)
            .setParameter(2, newState);
    return (String) functionQuery.getSingleResult();
}
\end{minted}
\captionof{listing}{Código da função setPlayerState\label{lst:setPlayerState}}

\paragraph{Exercício 2e} Este exercício apenas requer a implementação de uma função. Esta também tem apenas como objetivo chamar uma função da base de dados e não
requer nível de isolamente acima do que está por definição em PostgreSQL. Tal como nas funções em 2d, esta apenas realiza uma \textit{query} para a função na
base de dados. A implementação encontra-se na listagem~\ref{lst:totalPontosJogador}.
\begin{minted}
[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\footnotesize,
    linenos
]
{Java}
public Long totalPontosJogador(int idJogador) {
    String query = "SELECT totalPontos from totalPontosJogador(?1)";
    Query functionQuery = em.createNativeQuery(query);
    functionQuery.setParameter(1, idJogador);
    return (Long) functionQuery.getSingleResult();
}
\end{minted}
\captionof{listing}{Código da função totalPontosJogador\label{lst:totalPontosJogador}}

%
% Secção 3.2
%
\section{Realização da Funcionalidade 2h} \label{sec32}

TODO(Descrever a funcionalidade)

%
% Secção 3.2.1
%
\subsection{Sem usar procedimentos e funções pgSql} \label{sec321}

TODO(Descrever a implementação sem pgSql)

%
% Secção 3.2.2
%
\subsection{Usando procedimentos e funções pgSql} \label{sec322}

TODO(Descrever a implementação com pgSql)

%
% Secção 3.3
%
\section{Funcionalidade Adicional} \label{sec33}

TODO(Aumentar a 20\% cena)

%
% Secção 3.3.1
%
\subsection{Implementação Com \textit{Optimistic Locking}} \label{sec331}

TODO(Descrever a implementação que usa optimistic locking)

%
% Secção 3.3.2
%
\subsection{Implementação Com \textit{Pessimistic Locking}} \label{sec332}

TODO(Descrever a implementação que usa pessimistic locking)

%
% Secção 3.3.3
%
\subsection{Testes da Funcionalidade}\label{sec333}

TODO(Descrever os testes e como se testou concorrência)